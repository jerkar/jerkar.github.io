<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>reference</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Java build tool">
    <meta name="author" content="Jerome Angibaud">
    <meta name="keywords" content="build,java,tool,automation,maven,ant,gradle,buildr,sbt,make,compiler,tester,jacoco">
    <meta name="generator" content="JBake">

    <!-- Le styles -->
    <link href="../../css/bootstrap.css" rel="stylesheet">
    <!-- <link href="../../css/bootstrap.min.css" rel="stylesheet">  -->
    <link href="../../css/asciidoctor.css" rel="stylesheet">
    <link href="../../css/base.css" rel="stylesheet">
    <link href="../../css/prettify.css" rel="stylesheet">
    <link href="../../css/jerkar.css" rel="stylesheet">

    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../../js/html5shiv.min.js"></script>
      
    <![endif]-->
    
      <!-- Fav and touch icons -->
    <!--<link rel="apple-touch-icon-precomposed" sizes="144x144" href="../assets/ico/apple-touch-icon-144-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="../assets/ico/apple-touch-icon-114-precomposed.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="../assets/ico/apple-touch-icon-72-precomposed.png">
    <link rel="apple-touch-icon-precomposed" href="../assets/ico/apple-touch-icon-57-precomposed.png">-->
    <link rel="shortcut icon" href="../../favicon.ico">
  
  	<!-- highlight.js -->
  	<script src="../../js/highlight.pack.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>
	<link rel="stylesheet" href="../../css/highlight-idea.css">
	
	<!-- sidebar css -->
	<link href="../../css/sidebar.css" rel="stylesheet">
	
		<link href="../../css/numberify.css" rel="stylesheet">
  
  </head>
  <body onload="prettyPrint()">
    <div id="wrap">

	<!-- Fixed navbar -->
    <div class="navbar navbar-default navbar-fixed-top" role="navigation">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand">
          	<img style="max-width:32px;margin-top: -7px;" src="../../img/logo.png">
          </a>
          <a class="navbar-brand">Jerkar</a>
        </div>
        <div class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
            <li><a href="../../index.html">Home</a></li>
            <li class="dropdown">
              <a href="#" class="dropdown-toggle" data-toggle="dropdown">Documentation<b class="caret"></b></a>
              <ul class="dropdown-menu">
                <li><a href="../../documentation/latest/getting_started.html">Getting Started</a></li>
                <li><a href="../../documentation/latest/reference.html">Reference Guide</a></li>
                <li><a href="../../documentation/latestfaq.html">Frequently Asked Questions</a></li>
                <li><a href="../../javadoc/latest/index.html">Javadoc</a></li>
              </ul>
            </li>
            <li><a href="../../about.html">About</a></li>
          </ul>
        </div>
       
        
      </div>
    </div>
    <div class="container">
	<p>
	<div id="sidebar-menu" class="col-md-3 hidden-xs hidden-sm">
    <ul class="main-menu nav nav-stacked affix">
        <li class="liexpandable"><a href="javascript:jerkarMoveTo('Introduction',2);">1.Introduction</a>
          <ul class="sub-menu">
            <li><a href="javascript:jerkarMoveTo('Lexical',3);">1.1.Lexical</a></li>
          </ul>
        </li>
        <li class="liexpandable"><a href="javascript:jerkarMoveTo('Jerkar Runtime',2);">2.Jerkar Runtime</a>
          <ul class="sub-menu">
            <li class="liexpandable"><a href="javascript:jerkarMoveTo('Launching Java Process',3);">2.1.Launching Java Process</a>
              <ul class="sub-menu">
                <li><a href="javascript:jerkarMoveTo('Embedded Mode',4);">2.1.1.Embedded Mode</a></li>
              </ul>
            </li>
            <li class="liexpandable"><a href="javascript:jerkarMoveTo('Jerkar Execution',3);">2.2.Jerkar Execution</a>
              <ul class="sub-menu">
                <li><a href="javascript:jerkarMoveTo('Command Line',4);">2.2.1.Command Line</a></li>
                <li class="liexpandable"><a href="javascript:jerkarMoveTo('Build class Compilation',4);">2.2.2.Build class Compilation</a>
                  <ul class="sub-menu">
                    <li><a href="javascript:jerkarMoveTo('Libraries Located on Maven/Ivy Repository ',5);">Libraries Located on Maven/Ivy...</a></li>
                    <li><a href="javascript:jerkarMoveTo('Libraries on File System',5);">Libraries on File System</a></li>
                    <li><a href="javascript:jerkarMoveTo('Build Definitions of other project',5);">Build Definitions of other pro...</a></li>
                  </ul>
                </li>
                <li><a href="javascript:jerkarMoveTo('Build Class Instantiation',4);">2.2.3.Build Class Instantiation</a></li>
              </ul>
            </li>
            <li class="liexpandable"><a href="javascript:jerkarMoveTo('Setting paths',3);">2.3.Setting paths</a>
              <ul class="sub-menu">
                <li><a href="javascript:jerkarMoveTo('Specify Jerkar user home',4);">2.3.1.Specify Jerkar user home</a></li>
                <li><a href="javascript:jerkarMoveTo('Specify the local repository cache',4);">2.3.2.Specify the local repository cac...</a></li>
                <li><a href="javascript:jerkarMoveTo('See the effective paths',4);">2.3.3.See the effective paths</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li class="liexpandable"><a href="javascript:jerkarMoveTo('Build Configuration',2);">3.Build Configuration</a>
          <ul class="sub-menu">
            <li><a href="javascript:jerkarMoveTo('Environment variables',3);">3.1.Environment variables</a></li>
            <li><a href="javascript:jerkarMoveTo('System properties',3);">3.2.System properties</a></li>
            <li class="liexpandable"><a href="javascript:jerkarMoveTo('Jerkar options',3);">3.3.Jerkar options</a>
              <ul class="sub-menu">
                <li><a href="javascript:jerkarMoveTo('Injecting options',4);">3.3.1.Injecting options</a></li>
                <li><a href="javascript:jerkarMoveTo('Retrieve Jerkar options',4);">3.3.2.Retrieve Jerkar options</a></li>
                <li><a href="javascript:jerkarMoveTo('Composite options',4);">3.3.3.Composite options</a></li>
                <li><a href="javascript:jerkarMoveTo('Standard options',4);">3.3.4.Standard options</a></li>
                <li><a href="javascript:jerkarMoveTo('How to document options ?',4);">3.3.5.How to document options ?</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li class="liexpandable"><a href="javascript:jerkarMoveTo('Master/Slave Projects',2);">4.Master/Slave Projects</a>
          <ul class="sub-menu">
            <li><a href="javascript:jerkarMoveTo('Principle',3);">4.1.Principle</a></li>
            <li><a href="javascript:jerkarMoveTo('Declare Slave Builds',3);">4.2.Declare Slave Builds</a></li>
            <li><a href="javascript:jerkarMoveTo('Invoke Slave Methods from Master Build Code',3);">4.3.Invoke Slave Methods from Master B...</a></li>
            <li><a href="javascript:jerkarMoveTo('Invoke Slave Builds from Command Line.',3);">4.4.Invoke Slave Builds from Command L...</a></li>
            <li><a href="javascript:jerkarMoveTo('Configure Slave Builds from command line.',3);">4.5.Configure Slave Builds from comman...</a></li>
          </ul>
        </li>
        <li class="liexpandable"><a href="javascript:jerkarMoveTo('Dependency Management',2);">5.Dependency Management</a>
          <ul class="sub-menu">
            <li><a href="javascript:jerkarMoveTo('What is a dependency ?',3);">5.1.What is a dependency ?</a></li>
            <li><a href="javascript:jerkarMoveTo('What is a scope ?',3);">5.2.What is a scope ?</a></li>
            <li class="liexpandable"><a href="javascript:jerkarMoveTo('Define a set of dependencies',3);">5.3.Define a set of dependencies</a>
              <ul class="sub-menu">
                <li><a href="javascript:jerkarMoveTo('Define scopes',4);">5.3.1.Define scopes</a></li>
                <li class="liexpandable"><a href="javascript:jerkarMoveTo('Defining different type of dependencies',4);">5.3.2.Defining different type of depen...</a>
                  <ul class="sub-menu">
                    <li><a href="javascript:jerkarMoveTo('Dependencies on local files',5);">Dependencies on local files</a></li>
                    <li><a href="javascript:jerkarMoveTo('Dependencies on files produced by computation',5);">Dependencies on files produced...</a></li>
                    <li class="liexpandable"><a href="javascript:jerkarMoveTo('Dependencies on Module',5);">Dependencies on Module</a>
                      <ul class="sub-menu">
                        <li><a href="javascript:jerkarMoveTo('Dependencies on Dynamic Versions',6);">Dependencies on Dynamic Vers...</a></li>
                        <li><a href="javascript:jerkarMoveTo('Specifying Maven Classifier and extension of the artifact',6);">Specifying Maven Classifier ...</a></li>
                        <li><a href="javascript:jerkarMoveTo('Choose the binary repository where to download your dependencies',6);">Choose the binary repository...</a></li>
                        <li><a href="javascript:jerkarMoveTo('What happen behind the hood ?',6);">What happen behind the hood ...</a></li>
                      </ul>
                    </li>
                  </ul>
                </li>
              </ul>
            </li>
            <li class="liexpandable"><a href="javascript:jerkarMoveTo('Bind Dependencies to Scopes',3);">5.4.Bind Dependencies to Scopes</a>
              <ul class="sub-menu">
                <li><a href="javascript:jerkarMoveTo('Simple scopes',4);">5.4.1.Simple scopes</a></li>
                <li><a href="javascript:jerkarMoveTo('Scope Mapping',4);">5.4.2.Scope Mapping</a></li>
                <li><a href="javascript:jerkarMoveTo('Default Scope Mapping',4);">5.4.3.Default Scope Mapping</a></li>
                <li><a href="javascript:jerkarMoveTo('Excluding Module from the Dependency Tree',4);">5.4.4.Excluding Module from the Depend...</a></li>
              </ul>
            </li>
          </ul>
        </li>
        <li class="liexpandable"><a href="javascript:jerkarMoveTo('Publication on binary repositories',2);">6.Publication on binary repositories</a>
          <ul class="sub-menu">
            <li class="liexpandable"><a href="javascript:jerkarMoveTo('Publish to a Maven repository',3);">6.1.Publish to a Maven repository</a>
              <ul class="sub-menu">
                <li><a href="javascript:jerkarMoveTo('Using raw API',4);">6.1.1.Using raw API</a></li>
                <li class="liexpandable"><a href="javascript:jerkarMoveTo('Using JkJavaBuild template',4);">6.1.2.Using JkJavaBuild template</a>
                  <ul class="sub-menu">
                    <li><a href="javascript:jerkarMoveTo('Using defaults',5);">Using defaults</a></li>
                    <li><a href="javascript:jerkarMoveTo('Using explicit settings',5);">Using explicit settings</a></li>
                  </ul>
                </li>
              </ul>
            </li>
            <li><a href="javascript:jerkarMoveTo('Publish to a Ivy repository',3);">6.2.Publish to a Ivy repository</a></li>
          </ul>
        </li>
        <li class="liexpandable"><a href="javascript:jerkarMoveTo('Plugins',2);">7.Plugins</a>
          <ul class="sub-menu">
            <li><a href="javascript:jerkarMoveTo('Declare Plugin in Build Class',3);">7.1.Declare Plugin in Build Class</a></li>
            <li class="liexpandable"><a href="javascript:jerkarMoveTo('Mention Plugins in the Command Line',3);">7.2.Mention Plugins in the Command Lin...</a>
              <ul class="sub-menu">
                <li><a href="javascript:jerkarMoveTo('Activate a Plugin',4);">7.2.1.Activate a Plugin</a></li>
                <li><a href="javascript:jerkarMoveTo('Configure a Plugin',4);">7.2.2.Configure a Plugin</a></li>
                <li><a href="javascript:jerkarMoveTo('Execute a Plugin Method',4);">7.2.3.Execute a Plugin Method</a></li>
              </ul>
            </li>
            <li><a href="javascript:jerkarMoveTo('Plugins Location',3);">7.3.Plugins Location</a></li>
          </ul>
        </li>
    </ul>
</div>
<script>
function jerkarMoveTo(title, level) {
    var elemType = 'h'+level;
    var elems = $(elemType);
    var elem;
    for (var i = 0; i < elems.length; i++) {
    	var candidate = elems[i];
    	if (candidate.outerText ===  title) {
    		elem = candidate;
    		break;
    	}
    }
    $('html, body').animate({
        scrollTop: $(elem).offset().top -50
    }, 200);
}
</script><p><div id="static-content" class="col-md-9"></p><h2>Introduction</h2>
<hr/><p>This document stands for reference guide and provides details about Jerkar behaviour. If you are new to Jerkar you may find other places to learn about Jerkar : </p>
<ul>
  <li><p>To have an overall vision of Jerkar, please have a <a href="http://jerkar.github.io/tour.html"><strong>tour</strong></a>.</p></li>
  <li><p>To get a step-by-step learning guide, please visit <a href="http://jerkar.github.io/documentation/latest/getting_started.html"><strong>Getting Started</strong></a>.</p></li>
</ul><p>If you are looking for how exactly Jerkar behaves or you want to get a pretty exhaustive list of Jerkar features, you are in the right place.</p><p>However, a document can not replace a source code or API for exhaustion, so please consult <a href="http://jerkar.github.io/javadoc/latest/index.html"><strong>javadoc</strong></a> or browse <a href="https://github.com/jerkar/jerkar/tree/master/org.jerkar.core"><strong>source code</strong></a> to get deeper knowledge. </p><p>Also, you're welcome to raise an issue in Git-hub for requesting an improvement on documentation.</p><h3>Lexical</h3><p>These terms are used all over the document, this lexical disambiguates their meanings.</p><p><strong>Build Class :</strong> These are files that define build for a given project. In Jerkar, those files are Java sources (.java files) located under <em>[PROJECT DIR]/build/def</em> directory and extending <code>org.jerkar.tool.JkBuild</code>.<br/>This term can also be use to designate the compiled build class (.class files) as this class is generated transparently by Jerkar.<br/>In general, there is a single build class by project, but it can have none (if your project embrace conventions strictly) or many if project developers estimates that make sense.<br/><em>[PROJECT DIR]/build/def</em> directory may contain other utilities classes and files consumed by build classes.</p><p><strong>Jerkar Options :</strong> This is a set of key-value used to inject parameters in builds. The options can be mentioned as command line arguments or stored in specific files.<br/>The section <em>Build Configuration</em> details about Jerkar options.</p><h2>Jerkar Runtime</h2>
<hr/><p>This section details what happens behind the cover when Jerkar is run.</p><h3>Launching Java Process</h3><p>Jerkar is a pure Java application requiring <strong>JDK 6 or above</strong>. <strong>JDK</strong> is required and <strong>JRE</strong> is not sufficient.<br/>Indeed Jerkar uses the JDK tools to compile java source files located under <em>[PROJECT DIR]/build/def</em>.</p><p>To ease launching Java process in command line, Jerkar provides native scripts ( <em>jerkar.bat</em> for <strong>Windows</strong> and <em>jerkar</em> for <strong>Unix</strong> ).<br/>These scripts do the following :</p>
<ol>
  <li><strong>Find the java executable path</strong> : If a <code>JAVA_HOME</code> environment variable is defined then it takes its value as <code>java</code> path. Otherwise it takes the <code>java</code> executable defined in the <em>PATH</em> of your OS.</li>
  <li><strong>Get java execution option</strong> : If an environment variable <code>JERKAR_OPTS</code> exists then its value is passed to the <code>java</code> command line parameters, otherwise default <code>-Xmx512m -XX:MaxPermSize=512m</code> is passed.</li>
  <li><strong>Set Jerkar classpath</strong> in the following order :
  <ul>
    <li>all jar and zip files found under <em>[WORKING DIR]/build/libs/build</em></li>
    <li>all jar and zip files found under <em>[JERKAR HOME]/libs/ext</em></li>
    <li>the <em>[JERKAR_HOME]/org.jerkar.core.jar</em> file</li>
  </ul></li>
  <li><strong>Run the <code>org.jerkar.tool.Main</code> class</strong> passing the command line argument as is. So if you have typed <code>jerkar myArg1 myArg2</code> the <code>myArg1 myArg2</code> will be passed as Java command-line arguments.</li>
</ol><h4>Embedded Mode</h4><p>Note that <strong><em>[JERKAR_HOME]/org.jerkar.core.jar</em></strong> comes after <strong><em>[WORKING_DIR]/build/libs/build/*</em></strong> in the classpath.<br/>This means that if a version of Jerkar (org.jerkar.core.jar) is in this directory, the build will be processed with this instance of Jerkar and not with the one located in in <em>[JERKAR HOME]</em>.</p><p>This is called the <strong>Embedded</strong> mode. It guarantees that your project will build regardless of Jerkar version installed on the host machine.<br/>This mode allows to build your project even if Jerkar is not installed on the host machine. just execute <code>java -cp build/libs/build/* org.jerkar.tool.Main</code> instead of <code>jerkar</code>.</p><h3>Jerkar Execution</h3><p>The <code>org.jerkar.tool.Main#main</code> is the entry point of Jerkar. This is the method you invoke to launch or debug a Jerkar build within your IDE.</p><p>It processes as follow :</p>
<ol>
  <li>Parse the command line.</li>
  <li>Populate system properties and Jerkar options from configuration files and command line (see <strong>build configuration</strong>).</li>
  <li>Pre-process and compile java source files located under under <em>[PROJECT DIR]/build/def</em> (see <strong>Build Definition Compilation</strong>).</li>
  <li>Instantiate the build class (see <strong>Build Class Instantiation</strong>)</li>
  <li>Inject options in build instance fields along the project root directory (see <strong>Build Configuration</strong>).</li>
  <li>Call the <code>init()</code> method on the build instance. This is the place to set location related variable and to configure plugins (see <strong>Plugins</strong>).</li>
  <li>Instantiate and configure plugins specified in command line arguments (see <strong>Mention Plugins in the Command Line</strong>).</li>
  <li>Invoke methods specified in command line arguments : methods are executed in the order they appear on the command line.</li>
</ol><h4>Command Line</h4><p>Jerkar parse the command line and process each arguments according its pattern :</p>
<ul>
  <li><p>Argument starts with <code>@</code> : This is an module import clause, the following will be used for adding a module to build class compile &amp; run classpath. For example if the command line contains <code>@com.google.guava:guava:18.0</code>, the build class will be compiled with Guava in its classpath and Guava will be also present in the classpath when the build class will be executed.</p></li>
  <li><p>Argument starts with <code>-</code> : This is an option declaration. The following is expectedto be formated as <em>optionName=optionValue</em>. For example, `-repo.build.url=http://my.repo.milestone/' will inject 'http://my.repo.milestone/' in the 'repo.build.url' Jerkar option.</p></li>
  <li><p>in the other cases, argument is considered as a method name to invoke on the build class instance.</p></li>
</ul><h4>Build class Compilation</h4><p>Jerkar compiles build class files prior to execute it. Build class files are expected to be in <em>[PROJECT DIR]/build/def</em>. If this directory does not exist or does not contains java sources, the compilation is skipped.<br/>Compilation outputs class files in <em>[PROJECT DIR]/build/output/def-bin</em> directory and uses classpath containing :</p>
<ul>
  <li>Java libraries located in <em>[PROJECT DIR]/build/libs/build</em>.</li>
  <li>Java libraries located in <em>[JERKAR HOME]/libs/ext</em> (not in embedded mode).</li>
</ul><p>You can augment the classpath with :</p>
<ul>
  <li>Java libraries hosted on a Maven or Ivy repositories</li>
  <li>Java libraries located on file system.</li>
  <li>Build definition (java sources) of other projects</li>
</ul><p>Information about extra lib to add to classpath are located in the build classes, inside <code>@JkImport</code> and <code>@JkProject</code> annotation.<br/>This information is read by parsing java <strong>source</strong> files, prior they are compiled.</p><h5>Libraries Located on Maven/Ivy Repository</h5><p>To add libraries from Maven/Ivy repository you need to annotate the build definition with <code>@JkImport</code>. This annotation takes an array of String as its default parameter so you can specify several dependencies.<br/>The mentioned dependencies are resolved transitively. </p>
<pre><code>@JkImport(`{&quot;commons-httpclient:commons-httpclient:3.1&quot;, &quot;com.google.guava:guava:18.0&quot;})
public class HttpClientTaskBuild extends JkJavaBuild {`
...
</code></pre><p>Url of the maven/ivy repositories is given by <code>repo.build.url</code> Jerkar option. If this option is not set, then it takes the url given by <code>repo.download.url</code> option. If the last is nor present as well, it falls back in Maven Central.<br/>If this repository needs credentials, you need to supply it through Jerkar options <code>repo.build.username</code> and <code>repo.build.password</code>.</p><p>Note that you can define several <code>repo.build.url</code> by separating then with coma (as <code>repo.build.url=http://my.repo1, http://my.repo2.snapshot</code>).</p><p>As for other repo, If the download repository is an Ivy repo, you have to prefix url with <code>ivy:</code> so for example you'll get <code>repo.build.url=ivy:file://my.ivy/repo</code>.</p><h5>Libraries on File System</h5><p>To add library from file system you need to annotate the build definition with <code>@JkImport</code>. This annotation takes an array of String as argument so you can specify several dependencies.<br/>The mentioned dependencies are not resolved transitively.<br/>The expected value is a Ant include pattern applied to the project root directory.</p>
<pre><code>@JkImport({&quot;commons-httpclient:commons-httpclient:3.1&quot;, &quot;build/libs/compile/*.jar&quot;})
public class HttpClientTaskBuild extends JkJavaBuild {`
...
</code></pre><p>This will include <em>commons-httpclient</em> and its dependencies in the classpath along all jar file located in <em>[PROJECT DIR]/build/libs/compile</em>.</p><h5>Build Definitions of other project</h5><p>Your build definitions can depends on build definitions of other projects. It is typically the case for multi-project builds.<br/>This capability allows to share build elements in a static typed way as the build definitions files can consume classes coming from build definitions of other projects.</p><p><code>@JkProject</code> is an annotation that applies on fields instance of <code>org.jerkar.tool.JkBuild</code> or its subclasses. This annotation contains the relative path of the consumed project.<br/>If the project build definition sources contain some <code>@JkProject</code> annotations, build class of the consumed project are pre-processed and compiled recursively.<br/>Classes and classpath of the consumed project are added to the build definition classpath of the consumer project.</p>
<pre><code>public class DistribAllBuild extends JkBuildDependencySupport {
	
	@JkProject(&quot;../org.jerkar.plugins-sonar&quot;)
	PluginsSonarBuild pluginsSonar;
	
	@JkProject(&quot;../org.jerkar.plugins-jacoco&quot;)
	PluginsJacocoBuild pluginsJacoco;
	
	@JkDoc(&quot;Construct a distrib assuming all dependent sub projects are already built.&quot;)
	public void distrib() {
		
		JkLog.startln(&quot;Creating distribution file&quot;);
		
		JkLog.info(&quot;Copy core distribution localy.&quot;);
		CoreBuild core = pluginsJacoco.core;  // The core project is got by transitivity
		File distDir = this.ouputDir(&quot;dist&quot;);
		JkFileTree dist = JkFileTree.of(distDir).importDirContent(core.distribFolder);
		...
</code></pre><h4>Build Class Instantiation</h4><p>Once build class compiled. Jerkar instantiate the build it.<br/>Build class is specified by the <code>buildClass</code> option if present. If not, it is the first class implementing <code>org.jerkar.tool.JkBuild</code>.<br/>If no class implementing <code>org.jerkar.tool.JkBuild</code> is found then the <code>org.jerkar.tool.builtins.javabuild.JkJavaBuild</code> is instantiated.</p><p>The class scanning processes classes in alphabetic order then sub-package in deep first. This mean that class <code>MyBuid</code> will be scanned prior <code>apackage.ABuild</code>, and <code>aa.bb.MyClass</code> will be scanned prior <code>ab.OtherClass</code>.</p><p>The <code>buildClass</code> option can mention a simple name class (class name omitting its package). If no class matches the specified <code>buildClass</code> then an exception is thrown.</p><p>The <code>org.jerkar.tool.JkBuild</code> constructor instantiate fields annotated with <code>@JkProject</code>. If a project build appears many time in the annotated project tree, a single instance is created then shared.</p><h3>Setting paths</h3><h4>Specify Jerkar user home</h4><p>Jerkar uses user directory to store user-specific configuration and cache files, in this document we refer to this directory using [Jerkar User Home].<br/>By default the this directory is located at <em>[User Home]/.jerkar</em> (_[User Home]_ being the path given by <code>System.getProperty(&quot;user.home&quot;);</code>.<br/>You can override this setting by defining the <code>JERKAR_USER_HOME</code> environment variable.<br/>You can programatically get this location in your build definition using <code>JkLocator.jerkarUserHome()</code>. </p><h4>Specify the local repository cache</h4><p>Jerkar uses <a href="http://ant.apache.org/ivy/">Apache Ivy</a> under the hood to handle module dependencies. Ivy downloads and stores locally artifacts consumed by projects.<br/>By default the location is <em>[JERKAR USER HOME]/repo-cache</em> but you can redefine it by defining the <code>JERKAR_REPO</code> environment variable.<br/>You can programatically get this location in your build definition using <code>JkLocator.jerkarRepositoryCache()</code>.</p><h4>See the effective paths</h4><p>The Jerkar logs displays the effective path at the very start of the process :</p>
<pre><code> _______           _                 
(_______)         | |                
     _ _____  ____| |  _ _____  ____ 
 _  | | ___ |/ ___) |_/ |____ |/ ___)
| |_| | ____| |   |  _ (/ ___ | |    
 \___/|_____)_|   |_| \_)_____|_|
                                     The 100% Java build tool.

Java Home : C:\UserTemp\I19451\software\jdk1.6.0_24\jre
Java Version : 1.6.0_24, Sun Microsystems Inc.
Jerkar Home : C:\software\jerkar
Jerkar User Home : C:\users\djeang\.jerkar
Jerkar Repository Cache : C:\users\djeang\.jerkar\cache\repo
...
</code></pre><h2>Build Configuration</h2>
<hr/><p>Jerkar build are configurable. Build definition classes can retrieve values defined at runtime by reading :</p>
<ul>
  <li>an environment variable</li>
  <li>a system property</li>
  <li>a Jerkar option</li>
</ul><h3>Environment variables</h3><p>There is nothing specific to Jerkar. Just set the environment variable as you usually do on your OS and get the value from build using the standard Java <code>System#getenv</code> method.</p><h3>System properties</h3><p>Naturally, your build definitions can read system properties by using the standard method <code>System#getProperty</code>.</p><p>Jerkar proposes 3 ways to inject system properties :</p>
<ul>
  <li>By editing <strong><em>[Jerkar Home]/system.properties</em></strong> file.<br/> Note that if you are running Jerkar in embedded mode, the <strong><em>[Jerkar Home]/system.properties</em></strong> file will not be taken in account but <strong><em>[project dir]/build/def/build/system.properties</em></strong>.</li>
  <li>By editing <strong><em>[Jerkar User Home]/system.properties</em></strong> file.</li>
  <li>By mentioning the property/value in Jerkar <strong>command line</strong> as <code>Jerkar doDefault -DmyProperty=myValue</code>.</li>
</ul><p>The <strong>command line</strong> takes precedence on <strong><em>[Jerkar User Home]/system.properties</em></strong> that in turn, takes precedence on <strong><em>[Jerkar Home]/system.properties</em></strong>.</p><p>In every case, defined system properties are injected after the creation of the java process (via <code>System#setProperty</code> method).</p><h3>Jerkar options</h3><p>Jerkar options are similar to system properties as it stands for a set of <strong>key/value</strong>. You can read it by using a dedicated API or let it be injected in Java field as explained below.</p><h4>Injecting options</h4><p>Jerkar proposes 3 ways to inject options :</p>
<ul>
  <li>By editing <strong><em>[Jerkar Home]/options.properties</em></strong> file.<br/> Note that if you are running Jerkar in embedded mode, the <strong><em>[Jerkar Home]/options.properties</em></strong> file will not be taken in account but <strong><em>[project dir]/build/def/build/options.properties</em></strong>.</li>
  <li>By editing <strong><em>[Jerkar User Home]/options.properties</em></strong> file.</li>
  <li>By mentioning the property/value in the Jerkar command line as <code>Jerkar doDefault -myOption=myValue</code>.</li>
</ul><p>As for system properties, The <strong>command line</strong> takes precedence on <strong><em>[Jerkar User Home]/options.properties</em></strong> that takes in turn, precedence on <strong><em>[Jerkar Home]/options.properties</em></strong>.</p><p>Note for boolean, when no value is specified, <code>true</code> will be used as default.</p><h4>Retrieve Jerkar options</h4><p>You can retrieve string values using the <code>JkOptions</code> API providing convenient static methods as <code>JkOptions#get</code>, <code>JkOptions#getAll</code> or <code>JkOptions#getAllStartingWith(String prefix)</code>.</p><p>You can also retrieve options just by <strong>declaring fields in build definition class</strong>.<br/>All non private instance fields of the build definition class, are likely to be injected as an option.</p><p>For example, if you declare a field like <code>protected int size = 3;</code> then you can override the default value by injecting the option value with any of the 3 ways described above.</p><p>Any fields <strong>except static fields or private fields</strong> can be used to inject options.<br/>If you want <strong>inject option in a private field</strong>, you must annotate it with <code>@JkDoc</code> as <code>@JkDoc private boolean myField;</code> </p><p>Note that the injected string value will be automatically converted to the target type.<br/>Handled types are <strong>String</strong>, <strong>all primitive types (and their wrappers)</strong>, <strong>enum</strong>, <strong>File</strong> and <strong>composite object</strong>.<br/>To get a precise idea on how types are converted see <a href="https://github.com/jerkar/jerkar/blob/master/org.jerkar.core/src/main/java/org/jerkar/tool/OptionInjector.java">this code</a>.</p><h4>Composite options</h4><p>Composite options are a way to structure your options. Say that you want to configure some server access with url, userName and passwsord,<br/>you can gather all these information in a object as </p>
<pre><code class="Java">class Server {
    private String url;
    private String userName;
    private String password;
    // ...
}
</code></pre><p>declare a Server field in your build :</p>
<pre><code class="Java">class MyBuild extends JkBuild {
   Server deployServer;
   ...
}
</code></pre><p>Then you can inject the server object using following options :</p>
<pre><code>deployServer.url=http:/myServer:8090/to
deployServer.username=myUsername
deployServer.password=myPassword
</code></pre><h4>Standard options</h4><p>Jerkar predefines some standard options that you can set for any build :</p>
<ul>
  <li>buildClass : This forces the build class to use. If this option is not null then Jerkar will used the specified class as the build class.<br/>Note that this can be a simple class as <code>MyBuildClass</code> is enough for running <code>org.my.project.MyBuildClass</code>.</li>
  <li>verbose : when <code>true</code> Jerkar will be more verbose at logging at the price of being slower and bloating logs. Default value is <code>false</code>.</li>
  <li>silent : when <code>true</code>nothing will be logged. Default is <code>false</code></li>
</ul><h4>How to document options ?</h4><p>If you want your option been displayed when invoking <code>jerkar help</code> you need to annotate it with <code>@JkDoc</code>.</p><p>For example :</p>
<pre><code>@JkDoc(&quot;Make the test run in a forked process&quot;)
private boolean forkTests = false;
</code></pre><h2>Master/Slave Projects</h2>
<hr/><p>Jerkar proposes 2 ways to deal with multi-project builds : </p>
<ul>
  <li>By using computed dependencies (see <strong>Dependency Managemment</strong>).</li>
  <li>By defining slave builds. This sections focus on this way.</li>
</ul><h3>Principle</h3><p>A build class (master build) declares its slave builds. The slave builds can be triggered individually or all-in-one from the master build.<br/>The slave builds are not aware they are slave. In fact any build can be used as slave. The relation is uni-directional </p><p><code>JkBuild</code> defines a method <code>#slaves()</code> returning the slaves of its instances (embodied as <code>org.jerkar.tool.JkSlaveBuilds</code>). Naturally this result is recursive as it contains slaves of the slaves and so on ...</p><p>From this result you can invoke a method for all slaves as <code>slaves().invokeOnAll(&quot;clean&quot;)</code>. The iteration order ensure that an invokation on a build can not be done until all its slaves has been invoked first. </p><p>Also from the command line you can invoke a method or set an option either for the master build only or for the master builds along all its slaves.</p><h3>Declare Slave Builds</h3><p>By default the <code>#slaves()</code> method returns all the <code>JkBuild</code> instance declared as field and annotated with <code>@JkProject</code>. You can modify this behavior by overriding this method.</p><p>This is an example of how to declare external build with <code>@JkProject</code> annotation.</p>
<pre><code>public class DistribAllBuild extends JkBuildDependencySupport {
	
	@JkProject(&quot;../org.jerkar.plugins-sonar&quot;)
	PluginsSonarBuild pluginsSonar;
	
	@JkProject(&quot;../org.jerkar.plugins-jacoco&quot;)
	PluginsJacocoBuild pluginsJacoco;
	
</code></pre><h3>Invoke Slave Methods from Master Build Code</h3><p>To invoke methods on all slaves you can use the <code>JkSlaveBuilds#invokeOnAll()</code> method from the instance returned by <code>JkBuild#slaves()</code>.</p><p>To invoke methods on a single slave, you can just invoke the method on the build instance as <code>pluginsJacoco.clean()</code>.</p><h3>Invoke Slave Builds from Command Line.</h3><p>When mentioning a method on the command line, it only applies to the master build. </p><p>If you want this method to be executed on the slave build as well, you must append a <code>*</code> at the end of the method name as <code>jerkar doSomething*</code>.</p><p>If a slave build do not have such a method, the build does not fail but warns it.</p><h3>Configure Slave Builds from command line.</h3><p>When mentioning an option on the command line, only the master build try to inject its corresponding field with the option value.</p><p>If you want to inject option field on the slave build as well, just append a <code>*</code> at the end of the option declaration as <code>jerkar aField=myValue*</code>.</p><p>If a build don't have such field, the injection simply does not happen and the build does not fail.</p><p>Note that <code>JkOptions</code> class is shared among master and slave builds so slave builds can have access to master options by using its static methods.</p><h2>Dependency Management</h2>
<hr/><h3>What is a dependency ?</h3><p>In build context, a <strong>dependency</strong> is an indication that can be resolved to a file (or a set of file) needed to accomplish certain part of the build.<br/>So for example if a project <em>Foo</em> has a <strong>dependency</strong> <em>bar</em>, this means that <em>Foo</em> may need the files indicated by <em>bar</em> for building.<br/>In Jerkar code, the dependency concept is embodied by the abstract <code>JkDependency</code> class.</p><p>Jerkar distinguishes 3 types of <strong>dependency</strong> :</p>
<ul>
  <li><strong>Arbitrary files</strong> located on the file system (Embodied by <code>JkFileSystemDependency</code> class). These files are assumed to be present on the file system when the build is running.</li>
  <li><strong>Files produced by a computation</strong> (Embodied by <code>JkComputedDependency</code> class). These files may be present on file system or not. If they are not present, the computation is run in order to produce the missing files. Generally the computation stands for the build of an external project.</li>
  <li><strong>Reference to module</strong> (Embodied by <code>JkModuleDependency</code>) hosted in a binary repository (Ivy or Maven for instance) : Jerkar can consume and resolve transitively any artifact located in a repository as you would do with Maven or Ivy.</li>
</ul>
<p class="alert alert-success">
For the last, Jerkar is using <b>Ivy 2.4.0</b> under the hood. The library is embedded in the Jerkar jar and is executed in a dedicated classloader. So all happens as if there where no dependency on Ivy.
</p><h3>What is a scope ?</h3><p>Projects may need dependencies to accomplish certain tasks and needed dependencies may vary according the executed tasks.<br/>For example, to <strong>compile</strong> you may need <em>guava</em> library only but to <strong>test</strong> you'll need <em>junit</em> library as well.<br/>To label dependencies according their usage, Jerkar uses the notion of <strong>scope</strong> (embodied by <code>JkScope</code> class). This notion is similar to the Maven scope.</p><p>A scope can <strong>inherit</strong> from one or several scopes. This means that if a scope <em>Foo</em> inherits from scope <em>Bar</em> then a dependencies declared with scope <em>Bar</em> will be also considered as declared with scope <em>Foo</em>.<br/>For instance, in <code>JkJavaBuild</code>, scope <code>TEST</code> inherits from <code>RUNTIME</code> that inherits from <code>COMPILE</code> so every dependencies declared with scope <code>COMPILE</code> are considered to be declared with scope <code>RUNTIME</code> and <code>TEST</code> as well. </p><p>By default, scopes are <strong>transitive</strong>. This has only a meaning for <strong>reference to module</strong>.<br/>If we have 3 modules having the following dependency scheme : <code>A</code> -&gt; <code>B</code> -&gt; <code>C</code> and the <code>A</code>-&gt; <code>B</code> dependency is declared with a <strong>non transitive scope</strong>, then <code>A</code> won't depend from <code>C</code>. </p><p>Projects consuming artifacts coming from Ivy repository can also use <code>JkScopeMapping</code> which is more powerful. This notion maps strictly to the <a href="http://ant.apache.org/ivy/history/2.2.0/ivyfile/configurations.html">Ivy configuration</a> concept.</p><h3>Define a set of dependencies</h3><p>To define a set dependencies (typically the dependencies of the project to build), you basically define a list of <strong>scoped dependency</strong> (embodied by <code>JkScopedDependency</code>). A <strong>scoped dependency</strong> is a <strong>dependency</strong> associated with zero, one or several <strong>scopes</strong>.</p><p>Practically, you define some scopes then you bind dependencies to these scopes.</p><p>The set of dependency concept is embodied by <code>JkDependencies</code> class. This class provides builder for easier instantiation. </p>
<pre><code class="Java">return JkDependencies.builder()
    .on(GUAVA, &quot;18.0&quot;).scope(COMPILE)  
    .on(JERSEY_SERVER, &quot;1.19&quot;).scope(COMPILE)
    .on(&quot;com.orientechnologies:orientdb-client:2.0.8&quot;).scope(COMPILE)
    .on(JUNIT, &quot;4.11&quot;).scope(TEST)
    .on(MOCKITO_ALL, &quot;1.9.5&quot;).scope(TEST, ANOTHER_SCOPE)
.build();
</code></pre><p>You can also omit the scope and set it later...</p>
<pre><code class="Java">JkDependencies deps = JkDependencies.builder()
    .on(GUAVA, &quot;18.0&quot;)
    .on(JERSEY_SERVER, &quot;1.19&quot;)
    .on(&quot;com.orientechnologies:orientdb-client:2.0.8&quot;)
    .on(JUNIT, &quot;4.11&quot;).scope(TEST)
    .on(MOCKITO_ALL, &quot;1.9.5&quot;).scope(TEST, ANOTHER_SCOPE)
.build();
...
deps = deps.withDefaultScope(COMPILE);
</code></pre><p>Here, both <code>GUAVA</code> and <code>JERSEY_SERVER</code> will be declared with <code>COMPILE</code> scope. </p><p>If you don't specify scope on a module and you don't set default scope, then at resolution time the dependency will be considerer as binded to every scope. </p>
<p class="alert alert-success">
<b>Note :</b> Instances of <code>JkDependencies</code> can be added to each other. Look at the <a href="http://jerkar.github.io/javadoc/latest/org/jerkar/api/depmanagement/JkDependencies.html">JkDepencies class API</a> for further details.
</p><h4>Define scopes</h4><p>In the examples above, we use the predefined scopes <code>COMPILE</code> or <code>TEST</code>. These scopes are standard scopes defined on the <a href="https://github.com/jerkar/jerkar/blob/master/org.jerkar.core/src/main/java/org/jerkar/tool/builtins/javabuild/JkJavaBuild.java">JkJavaBuild class</a>.<br/>So if your build definition class inherit from <code>JkJavaBuild</code> template you won't need to create it. </p><p>If you need to create your own <em>scope</em>, a good practice is to declare it as java constant (<code>static final</code>) as it will be reusable anywhere all over your build definition.</p><p>As an example, these are the scopes declared in <code>JkJavaBuild</code> :</p>
<pre><code class="Java">public static final JkScope PROVIDED = JkScope.of(&quot;provided&quot;).transitive(false)
    .descr(&quot;Dependencies to compile the project but that should not be embedded in produced artifacts.&quot;);

public static final JkScope COMPILE = JkScope.of(&quot;compile&quot;)
    .descr(&quot;Dependencies to compile the project.&quot;);

public static final JkScope RUNTIME = JkScope.of(&quot;runtime&quot;).extending(COMPILE)
	.descr(&quot;Dependencies to embed in produced artifacts (as war or fat jar files).&quot;);

public static final JkScope TEST = JkScope.of(&quot;test&quot;).extending(RUNTIME, PROVIDED)
	.descr(&quot;Dependencies necessary to compile and run tests.&quot;); 
</code></pre><h4>Defining different type of dependencies</h4><p>This section describes how to declare different types of dependencies.</p><h5>Dependencies on local files</h5><p>You just have to mention the path of one or several files. If one of the files does not exist at resolution time (when the dependency is actually retrieved), build fails.</p>
<pre><code>    @Override
    protected JkDependencies dependencies() {
        final File depFile1 = new File(&quot;/my/file1.jar&quot;);  // file with absolute path
    	final File depFile2 = file(&quot;zips/file2.zip&quot;);  // file related to project root dir
        return JkDependencies.builder()
            .on(depFile1, depFile2, file(&quot;libs/my.jar&quot;)).build();
    }
		
</code></pre><h5>Dependencies on files produced by computation</h5><p>It is typically used for <strong>multi projects builds</strong> projects.</p><p>The principle is that if the specified files are not found, then the computation is run in order to generate the missing files.<br/>If some files still missing after the computation has run, the build fails.</p><p>This mechanism is quite simple yet powerful as it addresses following use cases :</p>
<ul>
  <li>Dependencies on files produced by other Jerkar project.</li>
  <li>Dependencies on files produced by external project built with any type of technology (Ant, Grunt, Maven, Gradle, SBT, Android SDK, Make, ...).</li>
  <li>Dependencies on files produced by a method of the main build.</li>
</ul><p>The generic way is to construct this kind of dependency using a <code>java.lang.Runnable</code>.</p>
<pre><code>private Runnable computation = new Runnable() {...}; 
	
File fooFile = new File(&quot;../otherproject/target/output/foo.jar&quot;);  // dependency file  
	
@Override
protected JkDependencies dependencies() {
return JkDependencies.builder()
    .on(JkComputedDependency.of(computation, fooFile)).build();
}
</code></pre><p>Here, if the <em>fooFile</em> is absent then the <strong>computation</strong> will be run prior to retry to find <em>FooFile</em>.</p><p>Jerkar provides some shortcuts to deal with other Jerkar projects : For this, you can create the dependency directly from the slave build instance. </p>
<pre><code>@JkProject(&quot;../foo&quot;)          // The external project path relative to the current project root
public JkJavaBuild fooBuild;  // This build comes from &#39;foo&#39; project 
	
@Override
protected JkDependencies dependencies() {
    return JkDependencies.builder()
	    .on(fooBuild.asComputedDependency(&quot;doPack&quot;, fooBuild.packer().jarFile() ))
    .build();
}
</code></pre><p>Here the method <code>doPack</code> of <code>fooBuild</code> will be invoked if the specified file does not exist.<br/>See <em>Multi Module Project</em> to get details how parameters are propagated to slave builds.</p><p>You can also use another kind of project mentioning the command line to run in order to build the project.</p>
<pre><code>File fooDir = new File(&quot;../../foo&quot;);  // base dir of a Ant project 
File fooJar = new File(fooDir, &quot;build/foo.jar&quot;);
JkProcess antBuild = JkProcess.of(&quot;ant&quot;, &quot;makeJar&quot;).withWorkingDir(fooDir));
...
@Override
protected JkDependencies dependencies() {
    return JkDependencies.builder()
        .on(JkProjectDependency.of(antBuild, fooJar)).scope(PROVIDED)  
    .build();
}
</code></pre><p>Here, if <em>fooJar</em> file does not exist, <code>ant makeJar</code> command line is invoked prior to retry to find the file.<br/>If the file still does not exist then the build fails.</p><h5>Dependencies on Module</h5><p>This is for declaring a dependency on module hosted in <em>Maven</em> or <em>Ivy</em> repository. Basically you instantiate a <code>JkModuleDepency</code> from it's group, name and version.</p>
<pre><code>...	
@Override  
protected JkDependencies dependencies() {
    return JkDependencies.builder()
        .on(GUAVA, &quot;18.0&quot;)
        .on(&quot;com.orientechnologies:orientdb-client:2.0.8&quot;)
        .on(&quot;my.group:mymodule:0.2-SNAPSHOT&quot;)
	.build();
}
...   
</code></pre><p>There is many way to indicate a module dependency, see <a href="http://jerkar.github.io/javadoc/latest/index.html?org/jerkar/api/depmanagement/JkModuleDependency.html">Javadoc</a> for browsing possibilities. </p><p>Note that a version ending by <code>-SNAPSHOT</code> has a special meaning : Jerkar will consider it <em>"changing"</em>. This means that it won't cache it locally and will download the latest version from repository. </p><h6>Dependencies on Dynamic Versions</h6><p>Jerkar allows to specify a version range, for example, the following is legal :</p>
<pre><code>...	
@Override  
protected JkDependencies dependencies() {
    return JkDependencies.builder()
        .on(GUAVA, &quot;16.+&quot;)
        .on(&quot;com.orientechnologies:orientdb-client:[2.0.8, 2.1.0[&quot;)
	.build();
}
...   
</code></pre><p>As Jerkar relies on Ivy under the hood, you can use any expression mentioned (here) [http://ant.apache.org/ivy/history/latest-milestone/ivyfile/dependency.html].</p><h6>Specifying Maven Classifier and extension of the artifact</h6><p>Maven or Ivy module dependencies need to be downloaded from a binary repository. This could be a managed repository (as <em>Nexus</em> or <em>Artifactory</em>), simple file system repo or a combination of any.</p>
<pre><code>...	
@Override 
protected JkDependencies dependencies() {
    return JkDependencies.builder()
        .on(&quot;my.group:mymodule:1.0.1:jdk15&quot;)
	.build();
}
...   
</code></pre><p>You can also precise the extension of the artifact :</p>
<pre><code>...	
@Override 
protected JkDependencies dependencies() {
    return JkDependencies.builder()
        .on(&quot;my.group:mymodule:1.0.1:jdk15@zip&quot;)
        .on(&quot;my.group:otherModule:1.0.15@exe&quot;)
	.build();
}
...   
</code></pre><h6>Choose the binary repository where to download your dependencies</h6><p>If use <code>JkBuildDependencySupport</code> template, or one of its subclass as <code>JkBuildJava</code>, the default is to use the repository mentioned in your JkOptions :<br/>- <code>repo.download.url</code> : the url of the download repository, default is Maven central :<a href="http://repo1.maven.org/maven2`">http://repo1.maven.org/maven2`</a>.<br/>- <code>repo.download.username</code> : the username credential to access to the repository (optional). Default is null cause Maven central does not require authentication.<br/>- <code>repo.download.password</code> : the password credential to access to the repository (optional). Default is null cause Maven central does not require authentication. </p><p>If the repository is an Ivy one, you should prefix the url with <code>ivy:</code> as <em>ivy:/my/shared/drive/repo</em></p>
<pre><code>repo.download.url=ivy:http://my/ivy/repo
repo.download.username=myIvyUsername
repo.download.password=myIvyPassword
</code></pre><p>You can also define it programmatically for richer and more flexible options:</p>
<pre><code>protected JkPublishRepos publishRepositories() {
    return JkPublishRepos.of(
        JkRepo.maven(&quot;http://my.snapshot.repo&quot;).asPublishSnapshotRepo())
            .and( 
        JkRepo.maven(&quot;http://my.release.repo&quot;).asPublishReleaseRepo());
}
</code></pre><h6>What happen behind the hood ?</h6><p>Jerkar uses <a href="http://ant.apache.org/ivy/">Apache Ivy</a> under the hood to resolve/fetch module dependencies.<br/>Ivy is invisible to the user except in some log output.<br/>The dependencies are downloaded in local cache located at <em>[JERKAR USER DIR]/cache/repo</em>.<br/>You can override this setting by defining the <code>JERKAR_REPO</code> environment variable.</p><h3>Bind Dependencies to Scopes</h3><p>The whole project dependency description lie in a single instance of <code>JkDependencies</code>. This class offers convenient factory methods and builder to define the dependencies.</p><h4>Simple scopes</h4><p>You can bind any kind of dependency to on one or several scopes as :</p>
<pre><code>private static final JkScope FOO = JkScope.of(&quot;foo&quot;); 

private static final JkScope BAR = JkScope.of(&quot;bar&quot;); 

protected JkDependencies dependencies() {
		return JkDependencies.builder()
		    .on(file(&quot;libs/foo3.jar&quot;)).scope(BAR)  
		    .on(file(&quot;libs/foo1.jar&quot;)).scope(BAR, FOO)  
			.on(&quot;com.foo:barcomp&quot;, &quot;1.19&quot;).scope(BAR, FOO)  
			.on(&quot;com.google.guava:guava, &quot;18.0&quot;)
		.build();
}
</code></pre><p>When the dependency is a <strong>module dependency</strong>, transitive resolution comes in play and more subtle concepts appear.<br/>For resolving <strong>module dependency</strong> Jerkar uses <a href="http://ant.apache.org/ivy/"><strong>Ivy</strong></a> under the cover and scopes are translated to Ivy <a href="http://ant.apache.org/ivy/history/latest-milestone/tutorial/conf.html"><em>configurations</em></a>.</p><p>So the above module dependencies are translated to Ivy equivalent :</p>
<pre><code>...
&lt;dependency org=&quot;org.foo&quot; name=&quot;barcomp&quot; rev=&quot;1.19&quot; conf=&quot;bar;foo&quot;/&gt;
&lt;dependency org=&quot;com.google.guava&quot; name=&quot;guava&quot; rev=&quot;18.0&quot;/&gt;
</code></pre><h4>Scope Mapping</h4><p>You can also specify a <em>scope mapping</em> (aka <em>Ivy configuration mapping</em>) for <strong>module dependencies</strong> :</p>
<pre><code>protected JkDependencies dependencies() {
		return JkDependencies.builder()
			.on(&quot;com.foo:barcomp&quot;, &quot;1.19&quot;)
				.mapScope(COMPILE).to(RUNTIME, BAR)
				.and(FOO, PROVIDED).to(&quot;fish&quot;, &quot;master(*)&quot;)
		.build();
}
</code></pre><p>So the above module dependencies are translated to Ivy equivalent :</p>
<pre><code>...
&lt;dependency org=&quot;org.foo&quot; name=&quot;barcomp&quot; rev=&quot;1.19&quot; conf=&quot;compile-&gt;runtime,bar; foo-&gt;fish,master(*); provided-&gt;fish,master(*)&quot;/&gt;
</code></pre><h4>Default Scope Mapping</h4><p>The way transitive dependencies are actually resolved depends on the <code>JkDependencyResolver</code> used for resolution.<br/>Indeed you can set <em>default scope mapping</em> on the resolver, through <code>JkResolutionParameter</code>. This setting ends at being translated to respectively <em>Ivy configuration mapping</em>.<br/><a href="http://ant.apache.org/ivy/history/2.2.0/ivyfile/configurations.html">This page</a> explains how <em>Ivy configurations</em> works.</p><h4>Excluding Module from the Dependency Tree</h4><p>When resolving dependency transitively you may grab unwanted dependencies. To filter them out you can exclude them from the tree using appropriate methods.</p>
<pre><code>final JkDependencies deps = JkDependencies.builder()
    .on(&quot;org.springframework:spring-context:4.2.1.RELEASE&quot;)
    .on(&quot;org.hibernate:hibernate-core:4.3.7.Final&quot;).excludeLocally(&quot;dom4j&quot;,&quot;dom4j&quot;)
    .excludeGlobally(&quot;antlr&quot;, &quot;antlr&quot;)
    .excludeGlobally(&quot;org.jboss.logging&quot;, &quot;*&quot;).build();
</code></pre><p><code>#excludeLocally</code> apply only to the module previously declared. So here, <em>dom4j</em> excludes will apply only for <em>hibernate-core</em> dependency. This means that if <em>dom4j</em> is a transitive dependency of <em>hibernate-core</em> then transitive resolution will stop at <em>dom4j</em>. If <em>spring-context</em> as a dependency on <em>dom4j</em> (direct or transitive) then the result will include <em>dom4j</em> along its dependencies as it has not been excluded from <em>spring-context</em> dependency. </p><p><code>#excludeGlobally</code> acts on the global result. If any of the declared dependencies have a dependency on <em>antlr</em> then this lib (and its dependencies) won't be part of the result.</p>
<p class="alert alert-success">
<b>Note :</b> You can use wild-card or regular expressions for both group and artifact name. In this case all matching dependencies will be excluded.
</p><h2>Publication on binary repositories</h2>
<hr/><p>Jerkar is able to publish on both Maven and Ivy repository. This includes repositories as <a href="http://www.sonatype.org/nexus/">Sonatype Nexus</a> or <a href="http://www.jfrog.com/artifactory/">Jfrog Artifactory</a>.</p><p>Maven and Ivy have different publication model, so Jerkar proposes specific APIs according you want to publish on a Maven or Ivy repository. </p><h3>Publish to a Maven repository</h3><p>Jerkar proposes a complete API to pubish on Maven repository. POM files will be generated by Jerkar according<br/>elements provided by users.</p><h4>Using raw API</h4><p>You can set minimal information in order to deploy a file on a Maven repository as below :</p>
<pre><code>File fileToPublish = new File(&quot;build/output/myFile.jar&quot;);
JkPublishRepo repo = JkRepo.maven(&quot;http://my.mvn.repo/publisher&quot;).asPublishRepo()
JkVersionedModule versionedModule = JkVersionedModule.of(&quot;myGroup:myName&quot;, &quot;0.2.1&quot;);
JkPublisher.of(repo).publishMaven(versionedModule, JkMavenPublication.of(fileToPublish), JkDependencies.on());
</code></pre><p>You can also set additional information in order to :</p>
<ul>
  <li>Publish more than one artifact.</li>
  <li>Produce &amp; publish checksum files for each published artifact.</li>
  <li>Mention if you wish or not to use unique snapshot (<a href="http://stackoverflow.com/questions/1243574/how-to-stop-maven-artifactory-from-keeping-snapshots-with-timestamps">What is it ?</a>).</li>
  <li>Feed generated pom with data necessary to publish on <a href="https://maven.apache.org/guides/mini/guide-central-repository-upload.html">central repository</a>.</li>
  <li>Sign published artifact with PGP</li>
</ul>
<p class="alert alert-success">
Not that for signing with PGP, you don't need to have PGP installed on Jerkar machine. Jerkar uses <a href="https://www.bouncycastle.org/">Bouncy Castle</a> internally to sign artifacts.
</p>
<pre><code>// You can sign your artifatcs with PGP
JkPgp pgp = JkPgp.ofSecretRing(new File(&quot;/usr/myName/pgp/privateRing&quot;), &quot;myPgpPhrase&quot;);

JkPublishRepo repo = JkRepo.maven(publishRepo)
JkPublishRepo repo = JkRepo.maven(publishRepo)
    .withCredential(&quot;myRepoUserName&quot;, &quot;myRepoPassword&quot;).asPublishRepo()
    .withUniqueSnapshot(false)
    .withSigner(pgp)
    .andSha1Md5Checksums(); // You can checksum each of published artifacts
			
JkVersionedModule versionedModule = JkVersionedModule.of(&quot;myGroup:myName&quot;, &quot;0.2.1&quot;);
		
// Optinal : if you need to add metadata in the generated pom
JkMavenPublicationInfo info = JkMavenPublicationInfo
    .of(&quot;my project&quot;, &quot;my description&quot;, &quot;http://myproject.github&quot;)
    .withScm(&quot;http://scm/url/connection&quot;)
    .andApache2License()
    .andGitHubDeveloper(&quot;myName&quot;, &quot;myName@provider.com&quot;);				
		
// Optional : if you want publish sources
File srcZip = ouputDir(&quot;src.zip&quot;);
JkZipper.of(this.src).to(srcZip);
		
JkMavenPublication publication = JkMavenPublication.of(jarFile).with(info).and(srcZip, &quot;sources&quot;);
JkPublisher.of(repo).publishMaven(versionedModule, publication, JkDependencies.on());
</code></pre><h4>Using JkJavaBuild template</h4><p>When using this template, the effort you must produce to publish artifacts is minimal or zero if you don't need special feature.<br/>The prerequisite is to setup <em>options.properties</em> according to your infrastructure.</p><h5>Using defaults</h5><p>If you don't specify anything the publication will occurs locally at : <em>[JERKAR USER HOME]/maven-publish-dir</em></p><p>If you specify only credential as</p>
<pre><code>repo.publish.username=myUsername
repo.publish.password=myPassword
</code></pre><p>Jerkar will use OSSRH public repository : <a href="https://oss.sonatype.org/content/repositories/snapshots">https://oss.sonatype.org/content/repositories/snapshots</a> for snapshots<br/>and <a href="https://oss.sonatype.org/content/repositories/releases">https://oss.sonatype.org/content/repositories/releases</a> for releases.<br/>For more precision about default see <a href="https://github.com/jerkar/jerkar/blob/master/org.jerkar.core/src/main/java/org/jerkar/tool/JkBuildDependencySupport.java"><code>JkDependencySupport#publishRepositories</code></a> method.</p><h5>Using explicit settings</h5><p>You can set explicit settings at [JERKAR USER DIR]/options.properties level, so every build will leverage from these settings</p>
<pre><code>repo.publish.url=https://my.nexus/snaphots
repo.publish.username=myNexusSnapshotUserName
repo.publish.password=myNexusSnapshotPassword
repo.release.url=https://my.nexus/releases
repo.release.username=myNexusReleaseUserName
repo.release.password=myNexusReleasePassword
</code></pre><p>In this case the snapshot artifacts (those with version's ending with '-SNAPSHOT') will be published on <a href="https://my.nexus/snaphots">https://my.nexus/snaphots</a> repository while the other will be published in <a href="https://my.nexus/releases">https://my.nexus/releases</a>.</p><p>If you mention only </p>
<pre><code>repo.publish.url=https://my.nexus/all
repo.publish.username=myNexusSnapshotUserName
repo.publish.password=myNexusSnapshotPassword
</code></pre><p>then everything will be published to <a href="https://my.nexus/all">https://my.nexus/all</a>.</p><p>You can also override `publishRepositories``in your build script so you can write your own specific logic to setup and select publish repositories. </p>
<pre><code>@Override  
protected JkPublishRepos publishRepositories() {
    return JkPublishRepos.ossrh(JkOptions.get(&quot;ossrh.username&quot;),
	    JkOptions.get(&quot;ossrh.password&quot;), pgp());
}
</code></pre><h3>Publish to a Ivy repository</h3><p>Publishing to an Ivy repository is similar to publishing to a Maven one, except :</p>
<ul>
  <li>The publishing creates a <em>ivy.xml</em> file instead of a <em>pom.xml</em> file.</li>
  <li>The publisher needs to declare at least one Ivy repository. If not the case, nothing will be published.</li>
  <li>You must feed the publish method with <code>JkIvyPublication</code> instead of <code>JkMavenPublication</code>.</li>
</ul><p>This give an example of build file publishing on ivy with specific scope mapping.</p>
<pre><code>public class IvyPublishBuild extends JkJavaBuild {
	
    {
        this.pack.tests = true;
        this.pack.javadoc = true;
    }
	
    @Override
    public JkModuleId moduleId() {
        return JkModuleId.of(&quot;org.jerkar&quot;, &quot;script-samples-ivy&quot;);
    }

    @Override
    public JkDependencies dependencies() {
        return JkDependencies.builder()
            .on(GUAVA, &quot;18.0&quot;)	
            .on(JERSEY_SERVER, &quot;1.19&quot;).mapScope(RUNTIME, TEST).to(COMPILE)
            .on(&quot;com.orientechnologies:orientdb-client:2.0.8&quot;)
            .on(JUNIT, &quot;4.11&quot;).scope(TEST)
            .on(MOCKITO_ALL, &quot;1.9.5&quot;).scope(TEST)
            .build();
    }
	
    @Override
    protected JkRepos downloadRepositories() {
        return JkRepo.ivy(this.repo.publish.url).and(JkRepo.mavenCentral());
    }
	
    @Override 
    protected JkPublishRepos publishRepositories() {
        return JkRepo.ivy(this.repo.publish.url).asPublishRepos();
    }
	
    @Override
    protected JkIvyPublication ivyPublication() {
        return JkIvyPublication.of(packer().jarFile(), COMPILE)
            .and(packer().jarTestFile(), TEST)
            .and(packer().javadocFile(), JAVADOC)
            .and(packer().jarSourceFile(), &quot;src&quot;, SOURCES)
            .and(packer().jarTestSourceFile(), &quot;src&quot;, SOURCES, TEST);	
    }

}
</code></pre><h2>Plugins</h2>
<hr/><p>Jerkar provides a plugable architecture. To be precise, build templates provided with Jerkar (<code>org.jerkar.tool.JkBuild</code>, <code>org.jerkar.tool.builtins.javabuild.JkJavaBuild</code>) are plugable.<br/>They provide methods designed for extension point. Methods designed for extension point alter their behavior according template plugins activated in the enclosing template.</p><p>Example for <code>JkJavaBuild</code> template : </p>
<pre><code>/**
 * Returns location of production source code (containing edited + generated sources).
 */
public JkFileTreeSet sources() {
    return JkJavaBuildPlugin.applySourceDirs(this.plugins.getActives(),
        editedSources().and(generatedSourceDir()));
}
</code></pre><p>By default this method simply returns the files mentioned by the <code>#editedSources()</code> and <code>#generatedSourceDir()</code>. If plugins<br/>are activated, the result may be altered as the <code>JkJavaBuildPlugin</code> class specifies :</p>
<pre><code>static JkFileTreeSet applySourceDirs(Iterable&lt;? extends JkBuildPlugin&gt; plugins, JkFileTreeSet original) {
    JkFileTreeSet result = original;
        for (final JkBuildPlugin plugin : plugins) {
            result = ((JkJavaBuildPlugin) plugin).alterSourceDirs(result);
        }
    return result;
}
	
/**
 * Override this method if the plugin need to alter the source directory to use for compiling.
 * 
 * @see JkJavaBuild#sources()
 */
protected JkFileTreeSet alterSourceDirs(JkFileTreeSet original) {
    return original;
}
</code></pre><p>For instance, the Eclipse plugin for <code>JkJavaBuild</code> redefines this method to enforce the source directories defined in the <em>.classpath</em> file. </p><p>To bind plugin to a template : you can either declare it inside the build class or mention it in the command line...</p><h3>Declare Plugin in Build Class</h3><p>The best place to declare plugin is within <code>#init()</code> method. Indeed, when this method is invoked, fields and project base directory have been already set to proper value.<br/>At this point you can choose either to activate it (mean that the the plugin is always taken in account) or just configure it (in this case the plugin is taken in account only if specified in command line).</p><p>To activate a plugin, just invoke <code>JkBuildPlugins#activate()</code> method passing the instantiated plugin as :</p>
<pre><code>@Override
protected void init() {
    JkBuildPluginSonar sonarPlugin = new JkBuildPluginSonar()
        .prop(JkSonar.HOST_URL, sonarEnv.url)
        .prop(JkSonar.BRANCH, &quot;myBranch&quot;);
    JkBuildPluginJacoco pluginJacoco = new JkBuildPluginJacoco();
    this.plugins.activate(sonarPlugin);
}
</code></pre><p>Here, the SonarQube plugin is active at each build. A SonarQube analysis is run when the <code>#verify()</code> method is invoked on the <code>JkBuild</code> instance.</p><p>But, if you need to configure the plugin without activating it, you must use <code>JkBuildPlugins#configure()</code> method instead :</p>
<pre><code>@Override
protected void init() {
    JkBuildPluginSonar sonarPlugin = new JkBuildPluginSonar()
        .prop(JkSonar.HOST_URL, sonarEnv.url)
        .prop(JkSonar.BRANCH, &quot;myBranch&quot;);
    JkBuildPluginJacoco pluginJacoco = new JkBuildPluginJacoco();
    this.plugins.configure(sonarPlugin);
}
</code></pre><p>SonarQube plugin is not activated unless you specify <code>#sonar</code> in the command line (see below).</p><h3>Mention Plugins in the Command Line</h3><p>You can both configure plugin, activate plugin and invoke plugin methods from the command line without declaring anything in the build definition files.</p><p>For such, you need to get the plugin name. By construction the plugin name is plugin class short name minus <em>JkBuildPlugin</em> with lower case at the first letter.<br/>Indeed, plugin classes are required to be called <code>JkBuildPluginXxxx</code> and so <code>xxxx</code> is the plugin name for <code>JkBuildPluginXxxx</code> plugin class.<br/>If 2 plugins has the same name in your classpath then you have to name it with the fully qualified class name of the plugin class (<code>xx.xxxx.xx.JkBuildPluginXxxx</code> for instance).</p><h4>Activate a Plugin</h4><p>To activate a plugin, you have to mention its name followed by a <code>#</code> in the command line. For example if you want to launch unit tests with Jacoco plugin activated, you may execute the following command line : <code>jerkar doUnitTest jacoco#</code>.</p><p>If a project has slave projects, then you can activate the plugin for both main and slave projects by mentioning a <code>*</code> after the plugin declaration as <code>jerkar doUnitTest jacoco#*</code>.</p><h4>Configure a Plugin</h4><p>Configuring a plugin consists in setting its instance fields via the option mechanism. So for setting a plugin field, just mention <code>-pluginName#fieldName=value</code> in the command line.</p><p>This setting will apply to both master and slave build plugin instances.</p><h4>Execute a Plugin Method</h4><p>Plugin provide extension point methods to alter template methods but can also provide their own methods.<br/>To invoke a plugin method, just mention <code>pluginName#methodName</code> in the command line. Any public zero argument method is valid.</p><p>If a project has slave projects, then you can invoke the plugin method for both main and slave projects by mentioning a <code>*</code> after the method invokation as <code>jerkar myPlugin#doSomething*</code>.</p><h3>Plugins Location</h3><p>To be activated or configured a plugin has to be in the Jerkar classpath. Plugins are assumed to be packaged as jar file. There is 3 ways to add a plugin in the classpath :</p>
<ul>
  <li>Add the jar file in <em>[JERKAR HOME]/libs/ext</em>. The plugin will be available for all builds within this Jerkar installation but some builds may be not portable to other Jerkar installation.</li>
  <li>Add the jar file in the <em>[PROJECT DIR]/build/libs/build</em> directory. The build is portable as the plugin jar will be provided with the build definition. If the build has dependencies, they should be provided as well.</li>
  <li>Publish the plugin in a Maven/Ivy repository and mention it in the <code>@JkImport</code> annotation. The build is portable as long as the plugin is available in the download repository.</li>
</ul>
<pre><code>@JkImport(`{&quot;my.comp:jerkar-plugin-myPlugin:1.1&quot;})
public class MyBuild extends JkJavaBuild {`
...
</code></pre><p>For now, Jerkar ships with several plugins out-of-the-box :</p>
<ul>
  <li>Eclipse : Leverage and generate Eclipse metadata files (included in <em>org.jerkar.core.jar</em>).</li>
  <li>Sonar : Excecutor for SonarQube code analyser (included in <em>org.jerkar.core-fat.jar</em>).</li>
  <li>Jacoco : Test coverage tool (included in <em>org.jerkar.core-fat.jar</em>).</li>
</ul><p>You can have a description of plugins available in your classpath by executing <code>jerkar helpPlugins</code>.</p><p></div> <!--end of wrapper div --> </p>
	</p>

	<hr />

		</div>
		<div id="push"></div>
    </div>
    
    <div id="footer">
      <div class="container">
        <p class="muted credit">&copy; 2014 | Mixed with <a href="http://getbootstrap.com/">Bootstrap v3.1.1</a> | Baked with <a href="http://jbake.org">JBake v2.3.2</a></p>
      </div>
    </div>
    
   
    
    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="../../js/jquery-1.11.1.min.js"></script>
    <script src="../../js/bootstrap.min.js"></script>
    <script src="../../js/prettify.js"></script>
 	<script>
 	    lastSelect = null;
    	$('.liexpandable').click(function(evt) {
    		var li = $(evt.target).parents("li").first();
    		var ul = li.find(".sub-menu").first();
    		console.log(ul.is(':visible'));
    		evt.stopPropagation();
    		if (ul.is(':visible') && li.html() !== lastSelect) {
    			lastSelect = li.html();
    			return;
    		}
    		lastSelect = li.html();
      		ul.toggle();
 		});
    </script>
    
    <!-- Google Analytics -->
    <script>
  		(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  		(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  		m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  		})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  		ga('create', 'UA-65554165-1', 'auto');
  		ga('send', 'pageview');
	</script>
    
  </body>
</html>